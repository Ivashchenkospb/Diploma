load "iovtk"
load "pipe"
load "MUMPS_seq"
include "gnuplotInterface.edp"
include "jsonmodule.edp"

/*------------------------------------------------------------------------------------------*/

/* Domain geometry and parameters *\
|   for filtration and backstress  |
\*          definition            */

real L = 3000.0; /* [m] */
real H = 2000.0; /* [m] */
real Lfrac = 200.0; /* [m] */
real kr = 1.0*1e-14; /* [m^2], Reservoir permeability */
real kf = kr*1e5; /* [m^2], Fracture permeability */
real mu = 1.0*1e-3; /* [Pa*s], Reservoir and fracture fluid viscosity */
real fiPorosity = 0.2; /* [], Porosity */
real E = 20.0*1e9; /* [Pa], Young modulus */
real nu = 0.21; /* [], Poisson coef */
real alpha = 1.0; /* [], Biot coef */
real lambda=E*nu/(1.0+nu)/(1.0-2*nu); /* [Pa], Lame coef */
real G=E/2.0/(1.0+nu); /* [Pa], Lame coef */
real PP=lambda+2.0*G;
real Q = 14.4*1e-5; /* [m^2/s] Injection per unit height (height = 10 m) */
// real Q = - 0.5*5.8*1e-6; /* [m^2/s] Injection per unit height (height = 10 m) */
real p0 = 30.0*1e6; /* [Pa], Outer pressure */
real dt = 1000.0; /* [s], Timestep */
real tMax = 86400.0*10; /* [s], Maximal time */
real KIc = 1.73*1e6; /* [Pa*m^0.5] Fracture toughness */
real Ct = 1.0e-10; /* [Pa^-1], Compressibility */

/*------------------------------------------------------------------------------------------*/

/* Domain geometry and parameters *\
\* for fracture width definition  */

real rho0 = 2300.0;
real rhow = 1000.0; 
real g = 9.80665;

real[int] layerBorder = [
    2350.0,
    2650.0,
    2660.0,
    2665.0,
    2675.0,
    2950.0
];

int[int] ProdLayers = [
    0,
    1,
    0,
    1,
    0
];

int nLayer = layerBorder.n - 1;
real HProdLayer = layerBorder[4] - layerBorder[3];

real[int] Ew = 1.0e9*[
    20.00,
    20.00,
    20.00,
    20.00,
    20.00
];

real[int] nuw = [
    0.31,
    0.21,
    0.31,
    0.21,
    0.31
];

real[int] sB = 1.0e6*[
    0.0,
    0.0,
    0.0,
    0.0,
    0.0
];

int nPoints = 500;
real penalty = 1.0e16*Ew[0];
int maxIter = 40;
real tol = 1.0e-6;
verbosity = 0;

/*  Domain definition and mesh generation   *\
\* for filtration and backstress definition */

int NN = 10;

int labelB = 1;
int labelR = 2;
int labelT = 3;
int labelL = 4;

real[int] xP = [0.0, L, L, 0.0];
real[int] yP = [0.0, 0.0, H, H];

int[int] nGamma = [1, H/L, 1, H/L] * NN;

int[int] labelGamma = [labelB, labelR, labelT, labelL];

border GammaDomain(t = 0.0, 1.0; i)
{
    int iNext = (i+1) % nGamma.n;

    x = xP[i]*(1-t) + xP[iNext]*t;
    y = yP[i]*(1-t) + yP[iNext]*t;
    label = labelGamma[i];
}

mesh Th = buildmesh(GammaDomain(nGamma));

real hMeshFiltr = H/1.5;
real lMeshFiltr = L/1.5;
for(int i = 0; i < 8; i++){
    hMeshFiltr /= 2.0;
    lMeshFiltr /= 1.2;
    Th = splitmesh(Th, 1 + 1*((x <= lMeshFiltr)*(y <= hMeshFiltr)));
}

/*   Domain definition and mesh generation  *\
\*      for fracture width definition       */

real frcS = 10.0;
int NNN = 20;

real xMin = layerBorder[0];
real xFracL = layerBorder[1] - frcS;
real xFracR = layerBorder[4] + frcS;
real xMax = layerBorder[5];

real yMax = (xMin + xMax) / 2.0 / 2.0 / 2.0 / 2.0;
real Hsize = xMax - xMin;
real Hfrac = xFracR - xFracL;

real[int] xPw = [xMin, xFracL, xFracR, xMax, xMax, xMin];
real[int] yPw = [0, 0, 0, 0, yMax, yMax];

int[int] nGammaW = [(xFracL - xMin)/Hsize, 
                   (xFracR - xFracL)/Hsize,
                   (xMax - xFracR)/Hsize,
                   yMax/Hsize, 1, yMax/Hsize] * NNN;

int labelBottom = 1;
int labelFrac = 2;
int labelRight = 3;
int labelTop = 4;
int labelLeft = 5;
int[int] labelGammaW = [labelBottom, labelFrac, labelBottom,
                        labelRight, labelTop, labelLeft];

border GammaDomainW( t = 0.0, 1.0; i ) {
    int iNext = (i + 1)%nGammaW.n;
    x = xPw[i]*(1.0 - t) + xPw[iNext]*t;
    y = yPw[i]*(1.0 - t) + yPw[iNext]*t;
    label = labelGammaW[i];
}

mesh Thw = buildmesh(GammaDomainW(nGammaW));
real hMeshElast = yMax;
real lMeshElast = Hfrac;
for(int i = 0; i < 6; i++){
    hMeshElast /= 2.0;
    Thw = splitmesh(Thw, 1 + 1*(y <= hMeshElast)*(x <= (xFracR + lMeshElast) && x >= (xFracL - lMeshElast)));
    lMeshElast /= 2.0;
    } 

/*  Fespace definition for   *\
\* filtration and backstress */

fespace Vh(Th, P2);
Vh p, phi;
Vh pOld;
Vh RHSQ;
pOld = p0;

Vh psi, khi;
Vh RHS = alpha*(p-p0)/PP;
Vh psix, psiy, psixx, psiyy, psixy, psiyx;
Vh deltaSx, deltaSxTot, deltaSy, deltaSyTot, deltaSxy;

Vh sigmaB = 0.0;

/*  Fespace definition for  *\
\*    elasticity problem    */

fespace Wh(Thw, [P2, P2]);
fespace Xh(Thw, P1);

Wh [u, v];
Wh [uIter, vIter];
Wh [phiw, psiw];
Xh Syy, SyyFull;

Xh pf;
Xh pEff = 0.0;
Xh pNet = 0.0;

Xh EFunc = Ew[0] * (x <= layerBorder[1]) + Ew[1] * (x > layerBorder[1] && x <= layerBorder[2])
           + Ew[2] * (x > layerBorder[2] && x <= layerBorder[3]) + Ew[3] * (x > layerBorder[3] && x <= layerBorder[4])
           + Ew[4] * (x > layerBorder[4]);
Xh nuFunc = nuw[0] * (x <= layerBorder[1]) + nuw[1] * (x > layerBorder[1] && x <= layerBorder[2])
            + nuw[2] * (x > layerBorder[2] && x <= layerBorder[3]) + nuw[3] * (x > layerBorder[3] && x <= layerBorder[4])
            + nuw[4] * (x > layerBorder[4]);
Xh sBFunc = sB[0] * (x <= layerBorder[1]) + sB[1] * (x > layerBorder[1] && x <= layerBorder[2]) 
            + sB[2] * (x > layerBorder[2] && x <= layerBorder[3]) + sB[3] * (x > layerBorder[3] && x <= layerBorder[4]) 
            + sB[4] * (x > layerBorder[4]);
Xh lambdaFunc = nuFunc*EFunc / ((1 + nuFunc) * (1 - 2*nuFunc));
Xh muFunc = EFunc / (2 + 2*nuFunc);
// Xh PrFunc = rhow*g*x;
Xh PrFunc = rhow*g*x + (p0 - rhow*g*x)*(x > layerBorder[1] && x <= layerBorder[2]) 
            + (p0 - rhow*g*x)*(x > layerBorder[3] && x <= layerBorder[4]);
Xh sigmaMin = (nuFunc / (1 - nuFunc)) * (rho0*g*x - alpha*PrFunc) + alpha*PrFunc;

macro grad(p)[dx(p), dy(p)] // EOM

/*  Weak problem formulation for   *\
\*    filtration and backstress    */

real[int] xdelta = [0.0];
real[int] ydelta = [0.0];
real[int] cdelta=[dt*Q];
matrix D = interpolate(Vh, xdelta, ydelta);
RHSQ[] = D*cdelta;

varf FiltrationBilinearForm(p, phi) = 
    int2d(Th)(fiPorosity*Ct*p*phi) 
    + int2d(Th)((dt*kr/mu)*grad(p)'*grad(phi))
    + int1d(Th, labelB)((dt*kf/mu)*dx(p)*dx(phi)*(x <= Lfrac))
    + on(labelT, p = p0)
    + on(labelR, p = p0);

varf FiltrationLinearForm(p, phi) = 
    int2d(Th)(fiPorosity*Ct*pOld*phi)
    + RHSQ[]
    + on(labelT, p = p0)
    + on(labelR, p = p0);

varf BackstressBilinearForm(psi, khi) = 
    int2d(Th)(grad(psi)'*grad(khi))
    + on(labelR, psi=0)
    + on(labelT, psi=0);

varf BackstressLinearForm(psi, khi)=
    - int2d(Th)(RHS*khi)
    + on(labelR, psi=0)
    + on(labelT, psi=0);

/*  Weak problem formulation for   *\
\*    fracture width definition    */

real sqrt2 = sqrt(2.0);
macro div(u, v) (dx(u) + dy(v)) // EOM
macro epsilon(u, v) [dx(u), dy(v), (dy(u) + dx(v))/sqrt2] // EOM

varf ElasticityBilinearForm([u, v], [phiw, psiw]) = 
    int2d(Thw)(
        lambdaFunc*div(u,v)*div(phiw, psiw) + 2.0*muFunc*epsilon(u, v)'*epsilon(phiw, psiw)
    )
    + on(labelBottom, v = 0.0);

varf PenaltyBilinearForm([u, v], [phiw, psiw]) =
    int1d(Thw, labelFrac)(
        penalty*v*(vIter < 0.0)*psiw
    )
    + on(labelBottom, v = 0.0);

varf RhsLinearForm([u, v], [phiw, psiw]) = 
    int1d(Thw, labelFrac)(
        pNet*psiw*(x <= layerBorder[4] && x >= layerBorder[3]) 
        + (1 - (x <= layerBorder[4] && x >= layerBorder[3]))*pNet*(vIter > 1.0e-4)*psiw
    )
    + on(labelBottom, v = 0.0);


int nSearch = int((xFracR - xFracL) / 0.1) + 1;
real[int] fractureLine(nSearch);
for (int i = 0; i < nSearch; ++i) {
    fractureLine[i] = xFracL + 0.1*real(i);
}

/*---------------------------------- MAIN CYCLE ----------------------------------*/

matrix Ae = ElasticityBilinearForm(Wh, Wh);
matrix BB = BackstressBilinearForm(Vh, Vh);

real[int] omega = [1.0, 0.75, 0.5, 0.3];
int nOmega = omega.n;
int[int] order = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
real pNetAverage = -10.0;
real pNetCrit = 2*KIc/sqrt(pi*(layerBorder[4] - layerBorder[3]));
real FracPressure = p0;
real wAverage = 0.0;
real wAverage1 = 0.0;
real bsAverage = 0.0;

int i = 0;
real t = 0;

{   
    matrix A = FiltrationBilinearForm(Vh, Vh);
    set(A, solver = sparsesolver);
    while(pNetAverage < 0.0){
        cout << endl;
        cout << "Time = " << t << " s" << endl;

        real[int] b = FiltrationLinearForm(0, Vh);
        p[] = A^-1*b;
        FracPressure = int1d(Th, labelB)(p*(x <= Lfrac))/Lfrac;
        pf = FracPressure;

        RHS = alpha*(p-pOld)/PP;
        real[int] bB = BackstressLinearForm(0, Vh);
        psi[] = BB^-1*bB;
        psix = dx(psi);
        psiy = dy(psi);
        psixx = dx(psix);
        psiyy = dy(psiy);
        deltaSy = lambda*(psixx+psiyy)+2*G*psiyy;
        deltaSyTot = deltaSy-alpha*(p-pOld);
        sigmaB = sigmaB + deltaSyTot;
        bsAverage = -int1d(Th, labelB)(sigmaB*(x <= Lfrac))/Lfrac;
        sB[1] = bsAverage;
        sB[3] = bsAverage;
        sBFunc = sB[0] * (x <= layerBorder[1]) + sB[1] * (x > layerBorder[1] && x <= layerBorder[2]) 
                + sB[2] * (x > layerBorder[2] && x <= layerBorder[3]) + sB[3] * (x > layerBorder[3] && x <= layerBorder[4]) 
                + sB[4] * (x > layerBorder[4]);

        pNet = pf - sigmaMin - sBFunc;
        pNetAverage = int1d(Thw, labelFrac)(pNet*(x <= layerBorder[4] && x >= layerBorder[3])) / (layerBorder[4] - layerBorder[3]);
        pOld = p;
        t = t + dt;
        i = i + 1;
        cout << endl;
    }

    while(t < tMax){
        cout << endl;
        cout << "Time = " << t << " s" << endl;

        matrix A = FiltrationBilinearForm(Vh, Vh);
        set(A, solver = sparsesolver);
        real[int] b = FiltrationLinearForm(0, Vh);
        p[] = A^-1*b;
        FracPressure = int1d(Th, labelB)(p*(x <= Lfrac))/Lfrac;
        pf = FracPressure;

        RHS = alpha*(p-pOld)/PP;
        real[int] bB = BackstressLinearForm(0, Vh);
        psi[] = BB^-1*bB;
        psix = dx(psi);
        psiy = dy(psi);
        psixx = dx(psix);
        psiyy = dy(psiy);
        deltaSy = lambda*(psixx+psiyy)+2*G*psiyy;
        deltaSyTot = deltaSy-alpha*(p-pOld);
        sigmaB = sigmaB + deltaSyTot;
        bsAverage = -int1d(Th, labelB)(sigmaB*(x <= Lfrac))/Lfrac;
        sB[1] = bsAverage;
        sB[3] = bsAverage;
        sBFunc = sB[0] * (x <= layerBorder[1]) + sB[1] * (x > layerBorder[1] && x <= layerBorder[2]) 
                + sB[2] * (x > layerBorder[2] && x <= layerBorder[3]) + sB[3] * (x > layerBorder[3] && x <= layerBorder[4]) 
                + sB[4] * (x > layerBorder[4]);

        pNet = pf - sigmaMin - sBFunc;
        pNetAverage = int1d(Thw, labelFrac)(pNet*(x <= layerBorder[4] && x >= layerBorder[3])) / (layerBorder[4] - layerBorder[3]);

        real absErrorL2 = 1.0;
        real normL2 = 1.0;
        real relErrorL2 = 1.0;
        int count = 0;
        int iOmega = 0;
        [uIter, vIter] = [0.0, 0.0];

        while (relErrorL2 > tol && count < maxIter) {
            matrix Ap = PenaltyBilinearForm(Wh, Wh);
            matrix Aw = Ae + Ap;
            real[int] bw = RhsLinearForm(0, Wh);
            set(Aw, solver=sparsesolver);
            u[] = Aw^-1*bw;
            
            normL2 = sqrt(int2d(Thw)(v^2));
            absErrorL2 = sqrt(int2d(Thw)((v - vIter)^2));
            relErrorL2 = absErrorL2 / normL2;

            uIter[] = omega[iOmega]*u[] + (1.0 - omega[iOmega])*uIter[];
            ++ count;

            if (count == maxIter && relErrorL2 > tol && iOmega + 1 < nOmega) {
                count = 0;
                iOmega += 1;  
            }
            cout << "       Elasticity   (" << count << ")    "<< omega[iOmega] << "    rel_error_L2 = " << relErrorL2 << " (" << tol << ")" << endl;
        }

        wAverage = int1d(Thw, labelFrac)(v*(x <= layerBorder[4] && x >= layerBorder[3])) / (layerBorder[4] - layerBorder[3]);
        wAverage1 = int1d(Thw, labelFrac)(v) / (xFracR - xFracL);

        // cout << endl;
        cout << "Lfrac = " << Lfrac << endl;
        // cout << "Time = " << t << " s" << endl;
        cout << "Pnet = " << pNetAverage  << "    PnetCrit = " << pNetCrit << endl;
        cout << "Frac pressure = " << FracPressure << endl;
        cout << "Backstress = " << bsAverage << endl;
        // cout << "wAverage = " << wAverage << endl;
        cout << "wAverage1 = " << wAverage1 << endl;
        cout << "Iteration - " << i << endl;

        // Syy = lambdaFunc*div(u, v) + 2.0*muFunc*dy(v);
        // SyyFull = Syy - alpha*PrFunc;
        // savevtk("./Results/ElasticityConstantFrac" + i + ".vtu", Thw, u, v, Syy, SyyFull, -sigmaMin, pNet, pEff, dataname = "u v Syy SyyFull Smin pNet pEff", order=order);
        // savevtk("./Results/FiltrationInj" + i + ".vtu", Th, p, sigmaB, psi, dataname = "p Backstress psi ", order=order);

        if(pNetAverage >= pNetCrit*0.95){
            Lfrac += 1.0;
            dt = 300.0;
            cdelta=[dt*Q];  // value of point source
            D = interpolate(Vh, xdelta, ydelta); // the interpolation matrix
            RHSQ[] = D*cdelta;
        }
        else{
            dt = 500;
            cdelta=[dt*Q];  // value of point source
            D = interpolate(Vh, xdelta, ydelta); // the interpolation matrix
            RHSQ[] = D*cdelta;
        }

        {
            string path = "./Results/result" + i + ".json";
            BeginJSONFile(path);

            real[int] vv(nPoints);
            real[int] ss(nPoints);
            real[int] ssb(nPoints);
            real[int] pr(nPoints);
            real[int] xx(nPoints);
            real hx = Hfrac / real(nPoints - 1);

            for (int i = 0; i < nPoints; ++i) {
                    xx[i] = xFracL + hx*real(i);
                    vv[i] = 1.0e3*v(xx[i], 0.0);
                    ss[i] = 1.0e-6*sigmaMin(xx[i], 0.0);
                    ssb[i] = ss[i] + 1.0e-6*sBFunc(xx[i], 0.0);
                    pr[i] = 1.0e-6*PrFunc(xx[i], 0.0);
                }

            WriteArray1DRealToJSON(path, "Borders", layerBorder, false);
            WriteArray1DIntToJSON(path, "ProdLayers", ProdLayers, false);
            WriteArray1DRealToJSON(path, "depth", xx, false);
            WriteArray1DRealToJSON(path, "halfwidth", vv, false);
            WriteArray1DRealToJSON(path, "sMin", ss, false);
            WriteArray1DRealToJSON(path, "sMinBack", ssb, false);
            WriteArray1DRealToJSON(path, "Pressure", pr, true);

            EndJSONFile(path);
        }

        // int n1 = 20;
        // real[int] xx1(n1);
        // real[int] vv1(n1);
        // for(int i = 0; i < n1; i++){
        //     xx1[i] = layerBorder[2] + 5.0/(n1 - 1)*i;
        //     vv1[i] = v(xx1[i], 0.0);
        // }
        // if(vv1.min > 1e-4){
        //     cout << "!!! Breakthrough !!!" << endl;
        //     exit(0);
        // }

        pOld = p;
        t = t + dt;
        i = i + 1;
        cout << endl;
    }
}