load "iovtk"
load "pipe"
load "MUMPS_seq"
include "gnuplotInterface.edp"

include "Parameters.edp"

include "ElasticityMeshGen.edp" 

include "ElasticityFespaceDef.edp"

macro grad(p)[dx(p), dy(p)] // EOM

include "ElasticityWeakProblem.edp"


/*---------------------------------- MAIN CYCLE ----------------------------------*/

matrix Ae = ElasticityBilinearForm(Wh, Wh);

real[int] omega = [1.0, 0.75, 0.5, 0.3];
int nOmega = omega.n;
int[int] order = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];

int i = 0;
real t = 0;
while(t < tMax){

    include "FiltrationMeshGen.edp" 
    include "FiltrationFespaceDef.edp"
    include "FiltrationWeakProblem.edp"

    matrix A = FiltrationBilinearForm(Vh, Vh);
    matrix BB = BackstressBilinearForm(Vh, Vh);
    set(A, solver = sparsesolver);
    real[int] b = FiltrationLinearForm(0, Vh);
    p[] = A^-1*b;

    RHS = alpha*(p-pOld)/PP;
    real[int] bB = BackstressLinearForm(0, Vh);
    psi[] = BB^-1*bB;
    psix = dx(psi);
    psiy = dy(psi);
    psixx = dx(psix);
    psiyy = dy(psiy);
    deltaSx = lambda*(psixx+psiyy)+2*G*psixx;
    deltaSxTot = deltaSx-alpha*(p-pOld);
    deltaSy = lambda*(psixx+psiyy)+2*G*psiyy;
    deltaSyTot = deltaSy-alpha*(p-pOld);
    sBfull = sBfull + deltaSyTot;
    real bsAverage = -int1d(Th, labelF)(sBfull)/Lfrac;
    sB[3] = bsAverage;

    pf = int1d(Th, labelF)(p)/Lfrac;
    sBFunc = sB[0] * (x <= layerBorder[1]) + sB[1] * (x > layerBorder[1] && x <= layerBorder[2]) 
              + sB[2] * (x > layerBorder[2] && x <= layerBorder[3]) + sB[3] * (x > layerBorder[3] && x <= layerBorder[4]) 
              + sB[4] * (x > layerBorder[4]);
    pEff = pf - alpha*PrFunc - sBFunc;
    pNet = pf - sigmaMin - sBFunc;

    real[int] bw = RhsLinearForm(0, Wh);

    real absErrorL2 = 1.0;
    real normL2 = 1.0;
    real relErrorL2 = 1.0;
    int count = 0;
    int iOmega = 0;
    [uIter, vIter] = [0.0, 0.0];

    cout << endl;
    cout << "Time = " << t << " s" << endl;

    while (relErrorL2 > tol && count < maxIter) {
        matrix Ap = PenaltyBilinearForm(Wh, Wh);
        matrix Aw = Ae + Ap;
        set(Aw, solver=sparsesolver);
        u[] = Aw^-1*bw;
        
        normL2 = sqrt(int2d(Thw)(v^2));
        absErrorL2 = sqrt(int2d(Thw)((v - vIter)^2));
        relErrorL2 = absErrorL2 / normL2;

        uIter[] = omega[iOmega]*u[] + (1.0 - omega[iOmega])*uIter[];
        ++count;

        if (count == maxIter && relErrorL2 > tol && iOmega + 1 < nOmega) {
            count = 0;
            iOmega += 1;  
        }

        cout << "    relaxation parameter = " << omega[iOmega] << " (" << iOmega + 1 << " / " << nOmega << ")" << endl;
        cout << "    iteration = " << count << " (" << maxIter << ")" << endl;
        cout << "    rel_error_L2 = " << relErrorL2 << " (" << tol << ")" << endl;
    }

    Sxx = lambdaFunc*div(u, v) + 2.0*muFunc*dx(u);
    Syy = lambdaFunc*div(u, v) + 2.0*muFunc*dy(v);

    savevtk("./Results/ElasticityResults" + i + ".vtu", Thw, u, v, Syy, sigmaMin, pNet, dataname = "u v Syy Smin pNet", order=order);
    // savevtk("./Results/solQ" + i + ".vtu", Th, p, sBfull, psi, psix, psiy, deltaSx, deltaSxTot, deltaSy, deltaSyTot,
    //         dataname = "p Backstress psi u v Sx SxTot Sy SyTot", order=order);

    pOld = p;
    t = t + dt;
    i = i + 1;
}
